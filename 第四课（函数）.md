<font size = 4>

# 大纲

- ### 局部变量、全局变量
- ###  函数缺省参数、不定长参数、命名参数
- ### 递归函数及应用
- ### 匿名函数及应用
- ### 项目实践

---
## 1. 函数（上）

函数相关的链接：[函数](http://www.runoob.com/python/python-functions.html)

<font size = 2>定义：函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。
可以理解为对实现某一功能的封装。</font>

- 函数的语法格式：
```
def 函数名称（参数）：
    函数体代码
    return 返回值
```

- 函数定义以及函数调用（函数名（参数））

<font color = red >实例1：</font>
```
#函数的定义
def print_user_info():
    print("name:zhangsan")
    print("age:20")
    print("gender:male")

print_user_info()
```

结果：

```
name:zhangsan
age:20
gender:male

```

- 函数参数
    1. 形参：定义函数时设置的参数
    2. 调用函数时传入的参数

<font color = red >实例2：</font>

```
#带参函数注意，1.调用函数时传入的参数个数与函数定义参数个数相同。2.参数顺序要相同
#有参无返回值函数
##形参：name，age，gender
##实参：悟空，20，male
def print_user_info2(name,age,gender):
    print("name:%s"%name)
    print("age:%d"%age)
    print("gender:%s"%gender)

print_user_info2("悟空",20,"male")
print_user_info2("八戒",18,"male")
print_user_info()
```

- 函数类型
    1. 无参无返回值函数
    2. 无参有返回值函数
    3. 有参无返回值函数
    4. 有参有返回值函数

<font color = red >实例3：</font>
```
#有返回值函数
def x_y_sum_return(x,y):
    res = x + y
    return res

z = x_y_sum_return(2,3)
print(z)
```
结果：
```
5
```

## 2. 变量
### 2.1 局部变量
- 函数内部定义函数
- 不同函数内的局部变量可以定义相同的名字，互不影响
- 作用范围：函数体内有效，其他函数不能直接使用

链接：[局部和全局变量](https://blog.csdn.net/dongtingzhizi/article/details/8973569)  <font size = 2> #此链接推荐阅读，讲的很详细，下面会摘取一些例子</font>

<font color = red >实例4：</font>

```
#局部变量
def set_name():
    name = "zhangsan"
    return name

def get_name(name):
    #name = "lisi"
    print(name)

nm = set_name()
get_name(nm)
```
结果：

```
lisi

#从结果可以看出，打印的并非zhangsan，而是lisi，因为调用的是get_name函数里面的局部变量name
```
### 2.2 全局变量
-  函数外部定义的变量
-  作用范围：可以再不同函数中使用
-  在函数内使用global关键字实现修改全局变量的值
-  全局变量命名建议以g_开头，如g_game

<font color = red >实例5：</font>

```
#全局变量
#可以在不同的函数中使用
'''
name = "zhangsan"
def get_name():
    print(name)

def get_name2():
    print(name)

get_name()
get_name2()
print(name)
```

结果：

```
zhangsan
zhangsan
zhangsan

#打印name，所有函数全部调用了全部变量的name
```

<font color = red >实例6：</font>

```
#修改全局变量的值
age = 20
def change_age():
    age = 25  #重新定义了一个局部变量age
    #global age
    #age = 25
    print("函数体内age=%d"%age)

change_age()
print("函数体外age=%d"%age)

print('================')

age = 20
def change_age():
    #age = 25  #重新定义了一个局部变量age
    global age
    age = 25
    print("函数体内age=%d"%age)

change_age()
print("函数体外age=%d"%age)
```

结果：

```
函数体内age=25
函数体外age=20

=======================
函数体内age=25
函数体外age=25

##可以看出，如果不对局部变量用关键词global进行申明，函数体外打印的值还是全局变量age = 20，如果对进行global申明，那函数体内的局部变量就会代替体外的全局变量成为新的全局变量，所以申明后的体外打印的age =25
```

<font color = red >实例7：</font>

```
#全局变量定义的位置
g_num1 = 100
def print_global_num():
    print("g_num1:%d"%g_num1)
    print("g_num2:%d"%g_num2)
    print("g_num3:%d"%g_num3)

g_num2 = 200
print_global_num()
g_num3 = 300
```

结果：

```
g_num1:100
g_num2:200
g_num3:300
```

<font color = red >实例8：</font>

```
#字典、列表作为全局变量，在函数内修改这种类型的全局变量中的元素

g_num_list = [1,2,3]
g_info_dict = {"name":"zhangsan","age":20}

def update_info():
    g_num_list.append(4)
    g_info_dict["gender"] = "male"

update_info()
print(g_num_list)
print(g_info_dict)

```
结果：

```
[1, 2, 3, 4]
{'name': 'zhangsan', 'age': 20, 'gender': 'male'}
```

#### 取自链接中的一些实例：

<font color = red >实例9：</font>

```
num = 100
def func():
    num = 123
    print(num)

func()
```
结果：
```
123

##函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量，不管全局域中有没有用到该变量名，函数中使用的将是局部变量
```

## 3. 函数参数
链接：[函数参数](http://www.runoob.com/python3/python3-function.html)  <font size= 2> ## 可在此链接查看函数的参数，参数分四种（必须参数，关键字参数，默认参数，不定长参数等）</font>

### 缺省参数

- 函数定义带有初始值的形参
- 函数调用时，缺省参数可传，也可不穿
- 缺省参数一定要位于参数列表的最后
- 缺省参数数量没有限制

<font color = red >实例10：</font>

```
#缺省参数
def x_y_sum(x,y=20):
    print("x=%d"%x)
    print("y=%d"%y)
    return  x + y

print(x_y_sum(20))
```
结果：
```
x = 20
y = 20
40
```
<font color = red >实例11：</font>
```
def x_y_sum2(y=10,x):
    return x + y
print(x_y_sum2(10))
```
结果：
```
 File "<ipython-input-31-cc4701538993>", line 1
    def x_y_sum2(y=10,x):
                ^
SyntaxError: non-default argument follows default argument

###从上面报错得知，缺省参数一定要位于参数列表的的最后
```

### 命名参数
- 调用带有参数的函数时，通过指定参数名称传入参数的值
- 可以不按函数定义的参数顺序传入

<font color = red >实例12：</font>

```
def x_y_sum(x=10,y=20):
    return  x + y
#注意：函数调用的时候命名参数的名称与函数定义时的形参名称相同，但是顺序可以不同
rs1 = x_y_sum(y=30,x=15)
rs2 = x_y_sum(x=15)
rs3 = x_y_sum()

print("rs1=%d"%rs1)
print("rs2=%d"%rs2)
print("rs3=%d"%rs3)
```
结果：
```
rs1=45
rs2=35
rs3=30

##结果可以看出 rs1是通过命名参数的的输入，得出的结果
##rs2是y是缺省参数，x是命名参数，相加得到的结果
##rrs3是相加的两个数都是缺省参数相加
```
### 不定长参数
- 函数可以接受不定个数的参数传入
- def function([formal_args,]*args)函数调用时，传入的不定参数会被封装成元组
- def function([formal_args,]**args)函数调用时，如果传入key = value的形式的不定长参数，会被封装成字典

<font color = red >实例13：</font>
```
#不定长参数
#第一种def fuction([formal_args,]*args)

def any_num_sum(x,y=10,*args):
    print("args={}".format(args))
    rs = x + y
    if len(args) > 0:
        for arg in args:
            rs += arg
    return rs
rs1 = any_num_sum(20,10,30,40,50,60)
```
结果：
```
args=(30, 40, 50, 60)
210

# x =  20 ， y = 10 然后再讲被封装成元组的不定长参数依次相加，得到结果210
```
<font color = red >实例14：</font>
```
#改变不定长参数的位置
def any_num_sum2(x,*args,y=10):
    print("args={}".format(args))
    print("x={}".format(x))
    print("y={}".format(y))
    rs = x + y
    if len(args) > 0:
        for arg in args:
            rs += arg
    return rs
    
rs2 = any_num_sum2(20,30,40,50,60,y=100)

```
结果：

```
args=(30, 40, 50, 60)
x=20
y=100
300

```

<font color = red >实例15：</font>
```
#第二种def fuction([formal_args,]**kvargs)

#养老 医疗 公积金

def social_insurance_comp(basic_money,**proportion):
    print(proportion)
    e_money = basic_money * proportion["e"]
    m_money = basic_money * proportion["m"]
    a_money = basic_money * proportion["a"]
    total_money = e_money + m_money + a_money
    return e_money,m_money,a_money,total_money

e,m,a,t = social_insurance_comp(8000,e=0.2,m=0.1,a=0.12)

print("养老：{},医疗：{}，公积金：{}，缴费总额：{}".format(e,m,a,t))
```
结果：

```
{'e': 0.2, 'm': 0.1, 'a': 0.12}
养老：1600.0,医疗：800.0，公积金：960.0，缴费总额：3360.0
```

### 拆包
- 对于定义了不定长参数的函数，在函数调用时需要把已定义好的元组或者列表传入到函数中，需要使用拆包方法

<font color = red >实例16：</font>
```
#拆包
#工资计算器

def salary_comp(basic_money,*other_money,**proportion):
    print("缴费基数:{}".format(basic_money))
    print("其他工资:{}".format(other_money))
    print("比例:{}".format(proportion))

other_money = (500,200,100,1000)
proportion_dict = {"e":0.2,"m":0.1,"a":0.12}
print('未使用拆包的：')
salary_comp(8000,other_money,proportion_dict)#未使用拆包
print('=========')
salary_comp(8000,*other_money,**proportion_dict)
```

结果：

```
未使用拆包的：
缴费基数:8000
其他工资:((500, 200, 100, 1000), {'e': 0.2, 'm': 0.1, 'a': 0.12})
比例:{}
=========
缴费基数:8000
其他工资:(500, 200, 100, 1000)
比例:{'e': 0.2, 'm': 0.1, 'a': 0.12}
##如果不拆包的话，就会使other_money和proportion_dict被封装成元组变为实参，进入函数内执行。
```

## 4. 递归函数和匿名函数
### 4.1 递归函数
- 函数调用自身
- 注意：递归过程中要有用于结束递归的判断

<font color = red >实例17：</font>

```
#递归函数，自身调用自身
'''
1! = 1
2! = 2 * 1
3! = 3 * 2 * 1
...
n! = n * (n-1)!
'''
#for循环实现

def recursive_for(num):
    rs = num
    for i in range(1,num):# (1,4) = [1,2,3)
        rs *= i
    return rs
rs = recursive_for(4)
print(rs)

##递归函数实现
def recursive(num):
    if num > 1:
        return num * recursive(num -1) #这里就是函数的递归，调用自身
    else:
        return num
print(recursive(4))
```

结果：
```
24 
24
```
### 4.2 匿名函数
- 用lambda关键字创建匿名函数
- 定义：lambda[参数列表]：表达式
- 匿名函数可以作为参数被传入其他函数

<font color = red >实例18：</font>
```
#匿名函数
sum = lambda x,y:x+y
print(sum(10,20))
#等价函数
def sum(x,y):
    return x + y

```
结果：
```
30
```

<font color = red >实例19：</font>

```
#1.匿名函数作为参数传入到自定义函数中

def x_y_comp(x,y,func):
    rs = func(x,y)
    print(rs)

x_y_comp(3,5,lambda x,y:x+y)
print("----------------")
x_y_comp(4,7,lambda x,y:x*y)
```

<font color = red >实例20：</font>

链接：[sort的用法](https://www.cnblogs.com/sunny3312/archive/2017/01/07/6260472.html)

```
#2.匿名函数作为python内置函数的参数使用

user_infos = [{"name":"zhangsan","age":20},{"name":"lisi","age":30},{"name":"wangwu","age":18}]

print(user_infos)
user_infos.sort(key=lambda info:info["age"])
print(user_infos)
user_infos.sort(key=lambda info:info["age"],reverse=True)
print(user_infos)
```
结果：
```
[{'name': 'zhangsan', 'age': 20}, {'name': 'lisi', 'age': 30}, {'name': 'wangwu', 'age': 18}]
[{'name': 'wangwu', 'age': 18}, {'name': 'zhangsan', 'age': 20}, {'name': 'lisi', 'age': 30}]
[{'name': 'lisi', 'age': 30}, {'name': 'zhangsan', 'age': 20}, {'name': 'wangwu', 'age': 18}]
```

## 项目实践
### 无人便利店V3版本
- 增加用户管理系统
- 增加用户购买日志管理系统
- 购物车结算系统升级，增加会员结算
- 增加推荐系统，提高订单量

```
#------------v3 start------------------#
#存储用户信息
g_user_id_set = set()
#存储用户购买日志
g_buy_logs = []
#------------v3 end------------------#
#仓库
def warehouse(item_type):
    # 泡面
    pm_list = ["老坛酸菜", "红烧牛肉", "酸辣粉", "拉面"]
    # 榨菜
    zc_list = ["老干妈", "乌江"]
    # 香肠
    xc_list = ["王中王", "蒜肠", "淀粉肠"]
    if item_type == "pm":
        return  pm_list
    elif item_type == "zc":
        return  zc_list
    elif item_type == "xc":
        return  xc_list

#检测货架上的商品是否需要补货
def check_add_rack(rack,item_type,item_counts):
    if len(rack) == 0:
        print("---正在更新货架，请稍等---")
        item_list = warehouse(item_type)
        while len(rack) < item_counts:
            rack_index = len(rack) % len(item_list)
            rack.append(item_list[rack_index])
        print("----商品已上架----")
#------------v3 start------------------#
#购物车结算系统
def buy_car_account(buy_car,if_vip):
    item_detail = {"老坛酸菜":5, "红烧牛肉":4, "酸辣粉":6, "拉面":7,"老干妈":10, "乌江":2,"王中王":2, "蒜肠":12, "淀粉肠":8}
    total_money = 0
    for item in buy_car:
        total_money += item_detail.get(item,0)
    if if_vip:
        vip_money = total_money * 0.9
        total_money = float("%.2f"%vip_money)
    return total_money

#用户管理系统
#1.添加新用户 2.判断一个用户是不是VIP
def user_manager_sys(user_id):
    if_vip = False
    if user_id in g_user_id_set:
        if_vip = True
        return if_vip
    else:#新用户
        g_user_id_set.add(user_id)
        return if_vip
#用户购买日志管理系统
#格式:[{"user_id":"user_id1","money":20,"items":(item1,itme2....)}]
def buy_log_manager_sys(user_id,money,*items):
    buy_log = {"user_id":user_id,"money":money,"items":items}
    g_buy_logs.append(buy_log)

#推荐系统
def recommend_sys(user_id):
    if user_manager_sys(user_id):#通过用户管理系统判断该用户是不是老用户
        user_item_set = set()#被推荐人历史购买商品
        other_user_item_dict = {} #其他用户历史购买商品 {"user_id":{item1,item2}}
        for log in g_buy_logs:
            user_id_key = log["user_id"]
            items_value = log["items"]
            if user_id_key == user_id:
                user_item_set.update(items_value)
            else:
                items_set = other_user_item_dict.get(user_id_key)
                if items_set == None:
                    other_user_item_dict[user_id_key] = set(items_value)
                else:
                    items_set.update(items_value)
                    other_user_item_dict[user_id_key] = items_set

        recommend_list = []#被推荐列表
        for value_set in other_user_item_dict.values():
            inner_set = user_item_set & value_set
            length = len(inner_set)
            if length > 0 and length < len(value_set):
                diff_set = value_set - user_item_set
                recommend_list.append({"common_num":length,"items":diff_set})
        if len(recommend_list) > 0:
            recommend_list.sort(key=lambda x:x["common_num"],reverse=True)
            recommend_set = recommend_list[0]["items"]
            return list(recommend_set) #集合转列表

# ------------v3 end------------------#
#购物大厅
def shopping_hall():
    # 三个空货架
    pm_rack = []
    zc_rack = []
    xc_rack = []
    #货架摆放商品数量
    pm_rack_counts = 1
    zc_rack_counts = 1
    xc_rack_counts = 1
    buy_car = []
    if_new_user = True
    while True:
        #自动检测货架是否需要补货
        check_add_rack(pm_rack,"pm",pm_rack_counts)
        check_add_rack(zc_rack,"zc",zc_rack_counts)
        check_add_rack(xc_rack,"xc",xc_rack_counts)
        if if_new_user:
            print("欢迎光临")
        item_id = input("==本店售卖商品：1 泡面，2 榨菜，3 香肠。请输入想要购买的商品编号：")
        if int(item_id) == 1:
            if len(pm_rack) >= 1:
                buy_car.append(pm_rack[len(pm_rack) - 1])
                pm_rack.pop()
            else:
                print("亲！非常抱歉，泡面已卖完。")
        elif int(item_id) == 2:
            if len(zc_rack) >= 1:
                buy_car.append(zc_rack[len(zc_rack) - 1])
                zc_rack.pop()
            else:
                print("亲！非常抱歉，榨菜已卖完。")
        elif int(item_id) == 3:
            if len(xc_rack) >= 1:
                buy_car.append(xc_rack[len(xc_rack) - 1])
                xc_rack.pop()
            else:
                print("亲！非常抱歉，香肠已卖完。")
        else:
            print("亲！您输入的商品还在火星，请输入在售的商品编号！")
            continue

        if_buy = input("请输入y或者n选择是否继续购物：")
        if if_buy == "n":
            if len(buy_car) > 0:
                # ------------v3 start------------------#
                if_vip = False
                user_id = ""
                while True:
                    user_id = input("请输入手机号作为用户id使用：")
                    if user_id != "":
                        if_vip = user_manager_sys(user_id)
                        break
                    else:
                        print("输入的手机号不能为空，请输入正确的手机号！")

                total_money = buy_car_account(buy_car,if_vip)
                print("您的购物车商品如下：",buy_car)
                print("$您本次消费金额{}元：".format(total_money))
                #购物日志管理
                buy_log_manager_sys(user_id, total_money, *buy_car)
                recommend_item_list = recommend_sys(user_id)
                if recommend_item_list != None:
                    print("买了该商品的其他用户，还买了{}".format(recommend_item_list))
                # ------------v3 end------------------#
                buy_car = []
                if_new_user = True
                print("欢迎下次光临")
            else:
                print("您没有购买任何商品")
                print("欢迎下次光临")
        else:
            if_new_user = False

shopping_hall()
```
## 作业
  伴随着奶茶馆销量稳步上升，五种奶茶口味中出现了一款爆款网红奶茶蒟蒻
冰奶茶，所以老板决定在每位顾客到店后就将这款奶茶推荐给大家，同时，在顾
客点单完成之前设置推荐选项，根据其余顾客的购物信息推荐，推荐方式如下：
将与该顾客口味最相近的顾客购买的其它奶茶口味编号中最大值所对应的奶茶
口味推荐给顾客。实现方式建议：
1. 用集合记录每位顾客购买的奶茶编号
2. 新顾客购买的奶茶编号集合与之前顾客的购买集合取交集，得到重合率最
高的记录。
3. 将补集元素中编号值最大的奶茶口味推荐。